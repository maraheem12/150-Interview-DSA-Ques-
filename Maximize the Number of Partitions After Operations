import java.util.Arrays;

class Solution {
    /**
     * Calculates the maximum number of partitions after changing at most one character in the string.
     *
     * @param s The input string.
     * @param k The maximum number of distinct characters allowed in a partition.
     * @return The maximum number of partitions possible.
     */
    public int maxPartitionsAfterOperations(String s, int k) {
        int n = s.length();
        
        // If k is 26, any string will result in a single partition, as there are only 26 lowercase letters.
        if (k == 26) {
            return 1;
        }

        // L[i]: number of partitions for prefix s[0...i-1]
        int[] L = new int[n + 1];
        // R[i]: number of partitions for suffix s[i...n-1]
        int[] R = new int[n + 1];

        // --- Calculate L (partitions from left) ---
        // L[i] corresponds to the prefix s[0...i-1]
        L[0] = 0;
        int partitions = 1;
        int mask = 0;
        for (int i = 0; i < n; i++) {
            int charBit = 1 << (s.charAt(i) - 'a');
            // Check if the new character would exceed the k distinct limit
            if ((mask | charBit) != mask && Integer.bitCount(mask) == k) {
                partitions++; // Start a new partition
                mask = charBit;
            } else {
                mask |= charBit; // Add character to the current partition's mask
            }
            L[i + 1] = partitions;
        }

        // --- Calculate R (partitions from right) ---
        // R[i] corresponds to the suffix s[i...n-1]
        R[n] = 0;
        partitions = 1;
        mask = 0;
        for (int i = n - 1; i >= 0; i--) {
            int charBit = 1 << (s.charAt(i) - 'a');
            if ((mask | charBit) != mask && Integer.bitCount(mask) == k) {
                partitions++; // Start a new partition
                mask = charBit;
            } else {
                mask |= charBit;
            }
            R[i] = partitions;
        }

        // The answer without any changes is L[n]. This is our baseline.
        int maxPartitions = L[n];

        // --- Iterate over all substrings s[i...j] ---
        // Consider each substring as a potential single partition after one modification.
        for (int i = 0; i < n; i++) {
            int[] freq = new int[26];
            int distinctCount = 0;
            for (int j = i; j < n; j++) {
                int charIdx = s.charAt(j) - 'a';
                if (freq[charIdx] == 0) {
                    distinctCount++;
                }
                freq[charIdx]++;

                // With one change, we can reduce the distinct count by at most 1.
                // So, if the original substring has more than k+1 distinct characters,
                // it's impossible to make it a valid partition. We can stop extending j.
                if (distinctCount > k + 1) {
                    break;
                }
                
                // If distinctCount <= k+1, it's possible to make s[i..j] one partition.
                int prefixParts = (i == 0) ? 0 : L[i];
                int suffixParts = (j == n - 1) ? 0 : R[j + 1];
                
                // The total partitions would be the sum of partitions from the three segments.
                maxPartitions = Math.max(maxPartitions, prefixParts + 1 + suffixParts);
            }
        }

        return maxPartitions;
    }
}
